import akshare as ak
import pandas as pd
from datetime import datetime, timedelta
import time
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
import warnings
from typing import Callable, Dict, Any, List
import pandas_ta as ta
import numpy as np
import xlsxwriter

# 忽略 pandas 的 SettingWithCopyWarning
warnings.filterwarnings('ignore', category=pd.errors.SettingWithCopyWarning)


# ==============================================================================
# 核心工具函数和配置
# ==============================================================================
class Config:
    """程序配置类"""

    def __init__(self):
        self.HOME_DIRECTORY = os.path.expanduser('~')
        self.SAVE_DIRECTORY = os.path.join(self.HOME_DIRECTORY, 'Downloads', 'CoreNews_Reports')
        self.TEMP_DATA_DIRECTORY = os.path.join(self.SAVE_DIRECTORY, 'ShareData')
        self.DATA_FETCH_RETRIES = 3
        self.DATA_FETCH_DELAY = 5
        self.MAX_WORKERS = 15
        self.CODE_ALIASES = {'代码': '股票代码', '证券代码': '股票代码', '股票代码': '股票代码'}
        self.NAME_ALIASES = {'名称': '股票简称', '股票名称': '股票简称', '股票简称': '股票简称'}
        self.PRICE_ALIASES = {'最新价': '最新价', '现价': '最新价', '当前价格': '最新价'}


def format_stock_code(code: str) -> str:
    """根据股票代码的开头数字，添加市场前缀。"""
    code_str = str(code).zfill(6)
    if code_str.startswith('6'):
        return 'sh' + code_str
    elif code_str.startswith(('0', '3')):
        return 'sz' + code_str
    elif code_str.startswith(('4', '8')):
        return 'bj' + code_str
    return code_str


# ==============================================================================
# 核心分析类 (集成 Fetching, Processing, Reporting)
# ==============================================================================
class StockAnalyzer:
    """
    股票数据获取、处理、分析和报告生成的核心类。
    """

    def __init__(self):
        self.config = Config()
        self.today_str = datetime.now().strftime("%Y%m%d")
        self.temp_dir = self.config.TEMP_DATA_DIRECTORY
        os.makedirs(self.temp_dir, exist_ok=True)
        self.executor = ThreadPoolExecutor(max_workers=self.config.MAX_WORKERS)
        self.start_time = time.time()

    def _get_file_path(self, base_name: str) -> str:
        """生成临时数据文件的完整路径。"""
        file_name = f"{base_name}_{self.today_str}.txt"
        return os.path.join(self.temp_dir, file_name)

    def _load_data_from_cache(self, file_path: str) -> pd.DataFrame:
        """从缓存加载数据。"""
        if os.path.exists(file_path):
            try:
                # 使用 '|' 分隔符，并确保股票代码是字符串格式
                df = pd.read_csv(file_path, sep='|', encoding='utf-8', dtype={'股票代码': str})
                print(f"  - 发现缓存，加载: {os.path.basename(file_path)}")
                return df
            except Exception as e:
                print(f"[WARN] 加载缓存 {os.path.basename(file_path)} 失败: {e}，将重新获取。")
        return pd.DataFrame()

    def _save_data_to_cache(self, df: pd.DataFrame, file_path: str):
        """保存数据到缓存。"""
        try:
            df.to_csv(file_path, sep='|', index=False, encoding='utf-8')
        except Exception as e:
            print(f"[ERROR] 保存数据到缓存 {os.path.basename(file_path)} 失败: {e}")

    def _safe_ak_fetch(self, fetch_func: Callable, file_base_name: str, **kwargs: Any) -> pd.DataFrame:
        """带缓存和重试的 AKShare 数据获取封装。"""
        file_path = self._get_file_path(file_base_name)
        cached_df = self._load_data_from_cache(file_path)
        if not cached_df.empty:
            return cached_df

        for i in range(self.config.DATA_FETCH_RETRIES):
            try:
                print(f"  - 正在尝试第 {i + 1}/{self.config.DATA_FETCH_RETRIES} 次获取数据: {file_base_name}...")
                df = fetch_func(**kwargs)
                if df is not None and not df.empty:
                    df = self._clean_and_standardize(df, file_base_name)
                    self._save_data_to_cache(df, file_path)
                    return df
                else:
                    print(f"[WARN] 数据返回为空或无效: {file_base_name}，重试中。")
                    time.sleep(self.config.DATA_FETCH_DELAY)
            except Exception as e:
                print(f"[ERROR] 获取 {file_base_name} 时出错: {e}，将在 {self.config.DATA_FETCH_DELAY} 秒后重试。")
                time.sleep(self.config.DATA_FETCH_DELAY)
        print(f"[FATAL] 所有重试均失败，返回空 DataFrame: {file_base_name}")
        return pd.DataFrame()

    def _clean_and_standardize(self, df: pd.DataFrame, df_name: str) -> pd.DataFrame:
        """通用数据清洗和列名标准化。"""
        if df.empty: return df

        # 1. 标准化列名
        for old, new in self.config.CODE_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)
        for old, new in self.config.NAME_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)
        for old, new in self.config.PRICE_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)

        if '股票代码' not in df.columns:
            # print(f"[WARN] {df_name} 数据中未找到 '股票代码' 列，跳过清洗。")
            return pd.DataFrame()

        # 2. 清洗数据
        df.dropna(subset=['股票代码'], inplace=True)
        df.drop_duplicates(subset=['股票代码'], inplace=True)
        df['股票代码'] = df['股票代码'].astype(str).str.zfill(6)

        # 3. 过滤ST股 (需要 '股票简称' 列，如果缺失则临时用代码)
        if '股票简称' not in df.columns:
            df['股票简称'] = df['股票代码']  # 临时使用

        cleaned_df = df[~df['股票简称'].str.contains('ST|st|退市|bj|BJ', case=False, na=False)].copy()

        if len(cleaned_df) == 0:
            print(f"[WARN] {df_name} 数据清洗后为空。")
            return pd.DataFrame()

        return cleaned_df

    def _get_all_raw_data(self) -> Dict[str, pd.DataFrame]:
        """集中获取所有数据源。"""
        print("\n>>> 正在初始化数据获取和缓存检查...")

        # 1. 基础行情和研报数据
        data = {
            'spot_data_all': self._safe_ak_fetch(ak.stock_zh_a_spot, "A股实时行情"),
            'main_report_raw': self._safe_ak_fetch(ak.stock_profit_forecast_em, "主力研报盈利预测"),
            'financial_abstract_raw': self._safe_ak_fetch(ak.stock_financial_abstract, "财务摘要数据"),
            'market_fund_flow_raw': self._safe_ak_fetch(ak.stock_fund_flow_individual, "市场资金流向",
                                                        symbol="5日排行"),
            'strong_stocks_raw': self._safe_ak_fetch(ak.stock_zt_pool_strong_em, "强势股池", date=datetime.now().strftime('%Y%m%d')),
            'consecutive_rise_raw': self._safe_ak_fetch(ak.stock_rank_lxsz_ths, "连续上涨"),
            'ljqs_raw': self._safe_ak_fetch(ak.stock_rank_ljqs_ths, "量价齐升"),
            'cxfl_raw': self._safe_ak_fetch(ak.stock_rank_cxfl_ths, "持续放量"),
        }

        # 2. 均线突破数据 (Akshare接口参数不同，需分开获取)
        data['xstp_10_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破10日均线", symbol="10日均线")
        data['xstp_30_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破30日均线", symbol="30日均线")
        data['xstp_60_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破60日均线", symbol="30日均线")

        # 3. 行业板块数据 (成分股需要实时获取，不适合缓存)
        print("\n>>> 正在获取行业板块成分股...")
        industry_board_df = self._safe_ak_fetch(ak.stock_board_industry_summary_ths, '行业板块名称')
        data['top_industry_cons_df'] = self._get_top_industry_constituents(industry_board_df)
        data['industry_board_df'] = industry_board_df  # 原始板块名称用于报告

        return data

    def _get_top_industry_constituents(self, industry_board_df: pd.DataFrame) -> pd.DataFrame:
        """获取涨幅前10板块的成分股。"""
        if industry_board_df.empty or '板块名称' not in industry_board_df.columns:
            return pd.DataFrame()

        top_industries = industry_board_df.sort_values(by='涨跌幅', ascending=False).head(10)
        all_constituents = []

        future_to_industry = {
            self.executor.submit(
                self._safe_ak_fetch,
                ak.stock_board_industry_cons_em,
                f"板块成分股_{row['板块名称']}",  # 使用不同名称防止缓存冲突
                symbol=row['板块名称']
            ): row['板块名称']
            for _, row in top_industries.iterrows()
        }

        for future in as_completed(future_to_industry):
            industry_name = future_to_industry[future]
            constituents_df = future.result()
            if not constituents_df.empty:
                if '代码' in constituents_df.columns:
                    constituents_df.rename(columns={'代码': '股票代码'}, inplace=True)
                constituents_df['股票代码'] = constituents_df['股票代码'].astype(str).str.zfill(6)
                constituents_df['所属板块'] = industry_name
                all_constituents.append(constituents_df[['股票代码', '所属板块']].drop_duplicates())

        if all_constituents:
            return pd.concat(all_constituents, ignore_index=True)
        return pd.DataFrame()

    def _fetch_hist_data_parallel(self, codes: List[str], days: int) -> pd.DataFrame:
        """并行获取指定股票的历史数据。"""
        print(f"\n正在为 {len(codes)} 只股票下载 {days} 天的历史数据...")

        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        start_date_str = start_date.strftime("%Y%m%d")
        end_date_str = end_date.strftime("%Y%m%d")

        # 缓存文件名增加代码数量，防止不同代码集混用缓存
        cache_name = f"MACD_hist_data_cache_{len(codes)}"
        file_path = self._get_file_path(cache_name)
        cached_df = self._load_data_from_cache(file_path)
        if not cached_df.empty:
            return cached_df

        all_data = []
        future_to_code = {}
        with ThreadPoolExecutor(max_workers=self.config.MAX_WORKERS) as executor:
            for code in codes:
                future = executor.submit(
                    ak.stock_zh_a_hist_tx,
                    symbol=format_stock_code(code),
                    start_date=start_date_str,
                    end_date=end_date_str,
                    adjust="hfq"  # 前复权
                )
                future_to_code[future] = code

            for future in as_completed(future_to_code):
                code = future_to_code[future]
                try:
                    hist_df = future.result()
                    if hist_df is not None and not hist_df.empty:
                        hist_df['股票代码'] = code
                        # 确保日期是字符串格式
                        if '日期' in hist_df.columns:
                            hist_df['日期'] = pd.to_datetime(hist_df['日期']).dt.strftime('%Y-%m-%d')
                        all_data.append(hist_df)
                except Exception as e:
                    # print(f"[ERROR] 错误：获取 {code} 的历史数据时出错: {e}")
                    pass

        if all_data:
            merged_df = pd.concat(all_data, ignore_index=True)
            self._save_data_to_cache(merged_df, file_path)
            return merged_df
        return pd.DataFrame()

    def _process_ta_signals(self, all_codes: List[str], hist_df_all: pd.DataFrame, spot_df: pd.DataFrame) -> Dict[
        str, pd.DataFrame]:
        """计算并提取所有技术指标信号。"""
        print(f"\n正在对 {len(all_codes)} 只股票进行技术分析...")
        results = {'MACD': [], 'CCI': [], 'RSI': [], 'BOLL': [], 'KDJ': []}
        grouped = hist_df_all.groupby('股票代码')

        # 预先准备股票简称
        stock_names = spot_df[['股票代码', '股票简称']].drop_duplicates(subset=['股票代码'])

        for code, group_df in grouped:
            try:
                if len(group_df) < 30: continue

                # 确保列名标准化用于 ta 库
                group_df.rename(columns={'收盘': 'close', '最高': 'high', '最低': 'low'}, inplace=True)
                if not all(col in group_df.columns for col in ['close', 'high', 'low']): continue

                # 安全连接指标
                ta_dfs = [
                    ta.macd(group_df['close'], append=False),
                    ta.cci(group_df['high'], group_df['low'], group_df['close'], append=False),
                    ta.rsi(group_df['close'], length=6, append=False).rename('RSI_6'),
                    ta.rsi(group_df['close'], length=14, append=False).rename('RSI_14'),
                    ta.bbands(group_df['close'], append=False),
                    ta.stoch(group_df['high'], group_df['low'], group_df['close'], append=False)
                ]
                group_df_ta = pd.concat([group_df.iloc[-2:], *ta_dfs], axis=1).tail(2)

                if len(group_df_ta) < 2: continue
                last_day = group_df_ta.iloc[-1]
                prev_day = group_df_ta.iloc[-2]
                name = stock_names[stock_names['股票代码'] == code]['股票简称'].iloc[0] if not stock_names[
                    stock_names['股票代码'] == code].empty else 'N/A'

                # --- 信号检测 ---
                # MACD 金叉 (DIF > DEA 且前一天 DIF < DEA)
                if all(c in last_day.index for c in ['MACD_12_26_9', 'MACDs_12_26_9']):
                    if (prev_day['MACD_12_26_9'] < prev_day['MACDs_12_26_9']) and \
                            (last_day['MACD_12_26_9'] > last_day['MACDs_12_26_9']):
                        results['MACD'].append(
                            {'股票代码': code, '股票简称': name, 'MACD (DIF)': f"{last_day['MACD_12_26_9']:.2f}",
                             'MACD信号线 (DEA)': f"{last_day['MACDs_12_26_9']:.2f}",
                             'MACD动能柱': f"{last_day['MACDh_12_26_9']:.2f}"})

                # KDJ 超卖金叉 (K > D 且前一天 K < D 且 K/D < 20)
                if all(c in last_day.index for c in ['STOCHk_14_3_3', 'STOCHd_14_3_3']):
                    k, d = last_day['STOCHk_14_3_3'], last_day['STOCHd_14_3_3']
                    pk, pd_ = prev_day['STOCHk_14_3_3'], prev_day['STOCHd_14_3_3']
                    if (pk < pd_) and (k > d) and (k < 20 and d < 20):
                        j = 3 * k - 2 * d
                        results['KDJ'].append(
                            {'股票代码': code, '股票简称': name, 'K值': round(k, 2), 'D值': round(d, 2),
                             'J值': round(j, 2)})

                # CCI 超卖 (CCI 站上 -100)
                if 'CCI_14_0.015' in last_day.index:
                    if (prev_day['CCI_14_0.015'] < -100) and (last_day['CCI_14_0.015'] > -100):
                        results['CCI'].append(
                            {'股票代码': code, '股票简称': name, '最新CCI值': f"{last_day['CCI_14_0.015']:.2f}"})

                # RSI 金叉 (RSI6 > RSI14 且前一天 RSI6 < RSI14 且 RSI14 处于 60-80)
                if all(c in last_day.index for c in ['RSI_6', 'RSI_14']):
                    if (prev_day['RSI_6'] < prev_day['RSI_14']) and (last_day['RSI_6'] > last_day['RSI_14']) and \
                            (60 <= last_day['RSI_14'] <= 80):
                        results['RSI'].append({'股票代码': code, '股票简称': name, 'RSI6': round(last_day['RSI_6'], 2),
                                               'RSI14': round(last_day['RSI_14'], 2)})

                # BOLL 低波动触及下轨 (收盘价低于中轨，且与下轨距离极近，波动率低)
                if all(c in last_day.index for c in ['BBU_20_2.0', 'BBM_20_2.0', 'BBL_20_2.0']):
                    close = last_day['close']
                    bbm, bbl, bbu = last_day['BBM_20_2.0'], last_day['BBL_20_2.0'], last_day['BBU_20_2.0']
                    band_width = bbu - bbl

                    is_near_lower_band = (close > bbl) and ((close - bbl) < (band_width * 0.05))
                    is_low_volatility = (band_width / bbm) < 0.05  # 带宽/中轨 < 5%

                    if is_near_lower_band and is_low_volatility:
                        results['BOLL'].append(
                            {'股票代码': code, '股票简称': name, '最新价格': f"{close:.2f}", '下轨线': f"{bbl:.2f}"})

            except Exception as e:
                # print(f"[ERROR] 计算股票 {code} 的技术指标时发生意外: {e}")
                continue

        # 确保只返回非空 DataFrame
        return {k: pd.DataFrame(v) for k, v in results.items() if v}

    def _process_xstp_and_filter(self, raw_data: Dict[str, pd.DataFrame], spot_df: pd.DataFrame) -> pd.DataFrame:
        """处理并合并均线突破数据，并进行多头排列筛选。"""
        print("正在处理并合并均线突破数据...")

        # 1. 清洗均线数据
        processed_df10 = raw_data['xstp_10_raw'].rename(columns={'最新价': '10日均线最新价'})
        processed_df30 = raw_data['xstp_30_raw'].rename(columns={'最新价': '30日均线最新价'})
        processed_df60 = raw_data['xstp_60_raw'].rename(columns={'最新价': '60日均线最新价'})

        # 2. 合并
        merged_df = pd.concat([
            processed_df10[['股票代码', '股票简称', '10日均线最新价']].dropna(subset=['股票代码']),
            processed_df30[['股票代码', '股票简称', '30日均线最新价']].dropna(subset=['股票代码']),
            processed_df60[['股票代码', '股票简称', '60日均线最新价']].dropna(subset=['股票代码'])
        ]).drop_duplicates(subset=['股票代码'])

        # 3. 重新合并均线价格，确保同一行有所有数据
        xstp_base = merged_df[['股票代码', '股票简称']].drop_duplicates()
        xstp_base = pd.merge(xstp_base, processed_df10[['股票代码', '10日均线最新价']], on='股票代码', how='left')
        xstp_base = pd.merge(xstp_base, processed_df30[['股票代码', '30日均线最新价']], on='股票代码', how='left')
        xstp_base = pd.merge(xstp_base, processed_df60[['股票代码', '60日均线最新价']], on='股票代码', how='left')

        # 4. 合并实时价格 (使用 spot_df 中的 '最新价')
        xstp_base = pd.merge(xstp_base, spot_df[['股票代码', '最新价']], on='股票代码', how='left')

        # 5. 类型转换和过滤
        cols_to_convert = [col for col in xstp_base.columns if '最新价' in col or col == '最新价']
        for col in cols_to_convert:
            xstp_base[col] = pd.to_numeric(xstp_base[col], errors='coerce')

        # 过滤条件: 1. 最新价>10日均线 2. 多头排列 (20>60 或 60>90)
        filtered_df = xstp_base[
            (xstp_base['最新价'] > xstp_base['10日均线最新价']) &
            (
                    (xstp_base['10日均线最新价'] > xstp_base['30日均线最新价'].fillna(-np.inf)) |
                    (xstp_base['30日均线最新价'] > xstp_base['60日均线最新价'].fillna(-np.inf))
            )
            ].copy()

        # 添加完全多头排列标记
        filtered_df['完全多头排列'] = filtered_df.apply(
            lambda row: '是' if row['10日均线最新价'] > row['30日均线最新价'] and row['30日均线最新价'] > row[
                '60日均线最新价'] else '否',
            axis=1
        )

        # 重新命名 '最新价' 为 '当前价格' 以避免与均线价混淆
        filtered_df.rename(columns={'最新价': '当前价格'}, inplace=True)
        return filtered_df.fillna('N/A')

    def _score_by_rank(self, df: pd.DataFrame, score_col: str, max_score: int = 15) -> pd.DataFrame:
        """根据排名为 DataFrame 打分，排名第一得 max_score 分。"""
        if df.empty: return pd.DataFrame()
        df = df.head(100).reset_index(drop=True)  # 只考虑前100名
        df[score_col] = df.index.to_series().apply(lambda x: max(1, max_score - x // (100 / max_score)))
        return df[['股票代码', score_col]]

    def _score_by_industry_coverage(self, top_industry_cons_df: pd.DataFrame,
                                    score_col: str = 'Industry_Score') -> pd.DataFrame:
        """根据被覆盖的强势板块数量打分。"""
        if top_industry_cons_df.empty: return pd.DataFrame()

        stock_counts = top_industry_cons_df['股票代码'].value_counts().reset_index()
        stock_counts.columns = ['股票代码', '板块覆盖次数']

        max_count = stock_counts['板块覆盖次数'].max()
        if max_count == 0: return pd.DataFrame()

        # 分数 = 覆盖次数 / 最大覆盖次数 * 10 (基准分)
        stock_counts[score_col] = (stock_counts['板块覆盖次数'] / max_count) * 10
        stock_counts[score_col] = stock_counts[score_col].round().astype(int)

        return stock_counts[['股票代码', score_col]]

    def _calculate_all_scores(self, processed_data: Dict[str, pd.DataFrame]) -> pd.DataFrame:
        """合并所有评分结果，计算总分。"""
        print("\n>>> 正在汇总和计算总分...")

        # 1. 提取所有有得分的股票代码作为基础
        all_codes = set()
        
        # 安全获取 TA 信号，如果键不存在则返回空 DataFrame
        macd_df = processed_data.get('MACD', pd.DataFrame())
        kdj_df = processed_data.get('KDJ', pd.DataFrame())
        cci_df = processed_data.get('CCI', pd.DataFrame())
        rsi_df = processed_data.get('RSI', pd.DataFrame())
        boll_df = processed_data.get('BOLL', pd.DataFrame())
        
        # 定义所有得分来源
        score_sources = {
            'Report_Score': processed_data['processed_main_report'][['股票代码', '机构投资评级(近六个月)-买入']],
            'FundFlow_Score': self._score_by_rank(processed_data['market_fund_flow_raw'], 'FundFlow_Score'),
            'Strong_Score': processed_data['strong_stocks_raw'][['股票代码']].assign(Strong_Score=10),
            'Rise_Score': processed_data['consecutive_rise_raw'][['股票代码', '连涨天数']].assign(
                Rise_Score=lambda x: (x['连涨天数'] / x['连涨天数'].max() * 10).round().astype(int)),
            'LJQS_Score': processed_data['ljqs_raw'][['股票代码']].assign(LJQS_Score=10),
            'CXFL_Score': processed_data['cxfl_raw'][['股票代码', '放量天数']].assign(
                CXFL_Score=lambda x: (x['放量天数'] / x['放量天数'].max() * 10).round().astype(int)),
            'Industry_Score': self._score_by_industry_coverage(processed_data['top_industry_cons_df']),
            # TA 信号 (使用安全获取的 DataFrame)
            'MACD_Score': macd_df[['股票代码']].assign(MACD_Score=15),
            'KDJ_Score': kdj_df[['股票代码']].assign(KDJ_Score=15),
            'CCI_Score': cci_df[['股票代码']].assign(CCI_Score=10),
            'RSI_Score': rsi_df[['股票代码']].assign(RSI_Score=10),
            'BOLL_Score': boll_df[['股票代码']].assign(BOLL_Score=10),
        }

        # 清理和收集所有股票代码
        for name, df in score_sources.items():
            if not df.empty and '股票代码' in df.columns:
                # 特殊处理研报分 (Report_Score)
                if name == 'Report_Score':
                    df.rename(columns={'机构投资评级(近六个月)-买入': 'Report_Score'}, inplace=True)
                    df['Report_Score'] = pd.to_numeric(df['Report_Score'], errors='coerce') * 10

                # 确保得分列名称正确
                if name.endswith('_Score') and name != 'Report_Score':
                    if df.shape[1] > 1 and df.columns[1] != name:
                        df.rename(columns={df.columns[1]: name}, inplace=True)

                all_codes.update(df['股票代码'].unique())

        if not all_codes: return pd.DataFrame()
        final_df = pd.DataFrame(list(all_codes), columns=['股票代码'])

        # 2. 合并所有得分
        for df in score_sources.values():
            if not df.empty and '股票代码' in df.columns:
                # 确保只有 '股票代码' 和一个分数列
                score_col = [col for col in df.columns if col.endswith('_Score')][0] if any(
                    col.endswith('_Score') for col in df.columns) else None
                if score_col:
                    final_df = pd.merge(final_df, df[['股票代码', score_col]].drop_duplicates(subset=['股票代码']),
                                        on='股票代码', how='left')

        # 3. 计算总分
        score_cols = [col for col in final_df.columns if col.endswith('_Score')]
        final_df[score_cols] = final_df[score_cols].fillna(0).astype(int)
        final_df['Total_Score'] = final_df[score_cols].sum(axis=1)

        # 4. 合并股票简称和最新价

        # 股票简称：优先从实时行情中获取，或从任何一个数据源中获取
        name_source = processed_data['spot_data_all'][['股票代码', '股票简称']].drop_duplicates(subset=['股票代码'])
        final_df = pd.merge(final_df, name_source, on='股票代码', how='left')

        # 最新价：从实时行情中获取 (列名为 '最新价')
        price_source = processed_data['spot_data_all'][['股票代码', '最新价']].drop_duplicates(subset=['股票代码'])
        if '最新价' in price_source.columns and '股票代码' in price_source.columns:
            final_df = pd.merge(final_df, price_source, on='股票代码', how='left')
        else:
            final_df['最新价'] = 'N/A'  # 无法获取价格

        # 5. 整理输出
        final_df['股票简称'] = final_df['股票简称'].fillna('N/A')
        final_df['最新价'] = final_df['最新价'].fillna('N/A')

        final_df = final_df[final_df['Total_Score'] > 0]  # 移除总分为0的股票
        final_df = final_df.sort_values(by='Total_Score', ascending=False).reset_index(drop=True)
        final_df.insert(0, '序号', range(1, len(final_df) + 1))

        # 6. 补充 TA 详情信息
        tech_dfs = {
            'MACD': macd_df, 'KDJ': kdj_df, 'CCI': cci_df,
            'RSI': rsi_df, 'BOLL': boll_df
        }
        for indicator, detail_df in tech_dfs.items():
            if not detail_df.empty:
                # 仅保留详情列，避免重复合并 '股票简称'
                detail_cols = [col for col in detail_df.columns if col not in ['股票简称']]
                final_df = pd.merge(final_df, detail_df[detail_cols], on='股票代码', how='left',
                                    suffixes=('', f'_{indicator}'))

        # 最终列顺序
        base_cols = ['序号', '股票代码', '股票简称', '最新价', 'Total_Score']
        final_cols = base_cols + score_cols + [col for col in final_df.columns if col not in base_cols + score_cols]
        final_df = final_df[[col for col in final_cols if col in final_df.columns]]

        return final_df

    def _generate_report(self, sheets_data: Dict[str, pd.DataFrame]):
        """生成 Excel 报告。"""
        print(f"\n>>> 正在生成 Excel 报告...")
        report_path = os.path.join(self.config.SAVE_DIRECTORY, f"股票筛选报告_{self.today_str}.xlsx")

        try:
            writer = pd.ExcelWriter(report_path, engine='xlsxwriter')
            workbook = writer.book

            # 定义格式
            header_format = workbook.add_format(
                {'bold': True, 'text_wrap': True, 'valign': 'top', 'fg_color': '#D7E4BC', 'border': 1})
            currency_format = workbook.add_format({'num_format': '#,##0.00'})
            code_format = workbook.add_format({'num_format': '@'})  # 文本格式

            for sheet_name, df in sheets_data.items():
                if df is None or df.empty:
                    print(f"  - 警告：工作表 '{sheet_name}' 数据为空，跳过创建。")
                    continue

                df.to_excel(writer, sheet_name=sheet_name, startrow=1, header=False, index=False)
                worksheet = writer.sheets[sheet_name]

                # 写入表头
                for col_num, value in enumerate(df.columns.values):
                    worksheet.write(0, col_num, value, header_format)

                # 设置列宽和格式
                for i, col in enumerate(df.columns):
                    max_len = max(df[col].astype(str).str.len().max(), len(col))
                    col_width = min(max_len + 2, 30)

                    if '价格' in col or '价' in col or '值' in col or '线' in col:
                        worksheet.set_column(i, i, col_width, currency_format)
                    elif '代码' in col:
                        worksheet.set_column(i, i, 10, code_format)
                    else:
                        worksheet.set_column(i, i, col_width)

            writer.close()
            print(f"  - 报告已成功生成并保存到: {report_path}")

        except Exception as e:
            print(f"[FATAL] 致命错误：生成 Excel 报告失败。原因: {e}")
            raise

    def run(self):
        """主运行方法。"""
        print(f"股票分析程序启动 (Today: {self.today_str})")

        # 清理旧的临时文件 (只清理当日文件以外的)
        for filename in os.listdir(self.temp_dir):
            if not filename.endswith(f"{self.today_str}.txt"):
                try:
                    os.remove(os.path.join(self.temp_dir, filename))
                except Exception:
                    pass
        print("旧的临时数据文件清理完成。")

        try:
            # 1. 获取所有原始数据 (已集成缓存和清洗)
            raw_data = self._get_all_raw_data()
            
            # --- 关键修复点：确定进行技术分析的股票列表 ---
            # 只有通过 ak.stock_zh_a_spot 获取并经过清洗的股票，才是有效的 A 股
            spot_df = raw_data.get('spot_data_all', pd.DataFrame())
            
            if spot_df.empty or '股票代码' not in spot_df.columns:
                # 重新从其他有代码的排行榜中提取，作为备用，但可能会包含更多无效代码
                print("[WARN] 实时行情数据为空，尝试从所有数据源中提取代码作为备用...")
                all_codes = set()
                for name, df in raw_data.items():
                    if '股票代码' in df.columns:
                        all_codes.update(df['股票代码'].unique())
            else:
                # **修复逻辑：只使用实时行情中有效的股票代码进行技术分析**
                all_codes = set(spot_df['股票代码'].unique())
                
            filtered_codes_list = list(all_codes)
            # --- 关键修复点结束 ---


            # 2. 历史数据获取和技术指标计算
            hist_df_all = self._fetch_hist_data_parallel(filtered_codes_list, days=90)

            # 3. 技术指标信号提取
            ta_signals = self._process_ta_signals(filtered_codes_list, hist_df_all, spot_df)

            # 4. 特殊数据处理
            processed_xstp_df = self._process_xstp_and_filter(raw_data, spot_df)

            # 5. 合并所有数据源和评分结果
            processed_data = {
                **raw_data,
                **ta_signals,
                'processed_xstp_df': processed_xstp_df,
                'processed_main_report': self._clean_and_standardize(raw_data['main_report_raw'], "主力研报盈利预测")
            }
            recommended_stocks = self._calculate_all_scores(processed_data)

            # 6. 准备报告数据
            sheets_data = {
                '指标汇总(推荐)': recommended_stocks,
                '主力研报筛选': processed_data['processed_main_report'],
                '均线多头排列': processed_data['processed_xstp_df'],
                '实时行情': spot_df,
                '市场资金流向': raw_data['market_fund_flow_raw'],
                '强势股池': raw_data['strong_stocks_raw'],
                '连续上涨': raw_data['consecutive_rise_raw'],
                '量价齐升': raw_data['ljqs_raw'],
                '持续放量': raw_data['cxfl_raw'],
                'MACD金叉': ta_signals.get('MACD', pd.DataFrame()),
                'KDJ超卖金叉': ta_signals.get('KDJ', pd.DataFrame()),
                'CCI超卖': ta_signals.get('CCI', pd.DataFrame()),
                'RSI金叉': ta_signals.get('RSI', pd.DataFrame()),
                'BOLL低波': ta_signals.get('BOLL', pd.DataFrame()),
                '前十板块成分股': raw_data['top_industry_cons_df'],
            }

            # 7. 生成报告
            self._generate_report(sheets_data)

        except Exception as e:
            print(f"\n[FATAL] 致命错误：数据分析流程意外终止。原因: {e}")
            raise

        finally:
            end_time = time.time()
            print(f"\n>>> 流程结束。总耗时: {timedelta(seconds=end_time - self.start_time)}")


# ==============================================================================
# 主执行入口
# ==============================================================================
if __name__ == '__main__':
    analyzer = StockAnalyzer()
    analyzer.run()
